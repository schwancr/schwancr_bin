from pyschwancr import BD
import numpy as np
import random
import re


def Force( R ):
	# Need to get the indices to look in V:
	I_x = int( R[0] * ( Nx - 1 ) )
	I_y = int( R[1] * ( Ny - 1 ) )

	if I_x >= Nx-1:
		I_x = Nx - 2
	if I_y >= Ny-1:
		I_y = Ny -2

	#if I_x < 0:
	#	I_x = 0
	#if I_y < 0:
	#	I_y = 0

	F_x = - ( V[ I_x + 1 , I_y ] - V[ I_x, I_y ] ) / dx

	F_y = - ( V[ I_x, I_y + 1 ] - V[ I_x, I_y ] ) / dy

	return np.array([ F_x, F_y ])
	
def NoUntilFcn( X ):
	return False


def Diffuse(x0, Vinit, dt = 0.0005, T=147., gammas=1E-21, noiseStdev=1, noiseMean=0, num_iter=100, until=NoUntilFcn ):
	"""
	This function will do Brownian dynamics for some number of iterations, but quitting if an until function returns true.

	Inputs:
	1) x0 - Initial vector of positions
	2) V - Potential generated by plot2Dhist.py. This script will do the proper conversions to get the right units.
	3) dt [ 0.0005 ] - Timestep
	4) T [ 100 ] - Temperature
	5) Gammas [ 1E-21 ] - Diffusion Coefficient
	6) noiseMean [ 0 ] - Gaussian distributed noise's mean (NOTE: You probably shouldn't change this)
	7) noiseStd [ 1 ] - Gaussian distributed noise's standard deviation 
	8) until [ NoUntilFcn (internal function that always returns False ) ] - A function pointer taking in a positions line and outputing true if you should stop and false otherwise
	9) num_iter [ 100 ] - Number of iterations to stop at
	
	Output
	1) X - Vector of positions over time
	2) Stopped - True if this function stopped due to an until call, False if it stopped due to the number of iterations.
	"""
	global Nx
	global Ny
	global V
	global dx
	global dy


	V = - 1.38E-23 * T * np.log( 10**( Vinit ) )
	V = V.T # This is needed to swap the axes
	Nx, Ny = V.shape
	dx = 1. / (Nx - 1.)
	dy = 1. / (Ny - 1.)

	bd = BD.BrownianDynamicsIntegrator(x0, Force, dt = dt, T = T, gammas = gammas, noiseStdev= noiseStdev)

	for i in range( num_iter ):
		bd.next()
		if until( bd.positions[-1] ):
			break

	return bd.positions, until( bd.positions[-1] )



def GetDiffusePfolds(x0, Vinit, U_cut = 0.1, F_cut = 0.9, foldDefinitionAxis = 0, dt = 0.0005, T=147., gammas=1E-21, noiseStdev=1, noiseMean=0, N = 100, low_is_folded = False ):
	"""
   This function will do Brownian dynamics for some number of iterations, but quitting if an until function returns true.

   Inputs:
   1) x0 - Initial vector of positions
   2) V - Potential generated by plot2Dhist.py. This script will do the proper conversions to get the right units.
	3) U_cut - Value to define the unfolded state
	4) F_cut - Value to define the folded state
	5) low_is_folded [ False ] - Boolean defining which state is folded and which is unfolded
   6) dt [ 0.0005 ] - Timestep
   7) T [ 100 ] - Temperature
   8) Gammas [ 1E-21 ] - Diffusion Coefficient
   9) noiseMean [ 0 ] - Gaussian distributed noise's mean (NOTE: You probably shouldn't change this)
   10) noiseStd [ 1 ] - Gaussian distributed noise's standard deviation 
   11) N [ 100 ] - Number of trajectories to use to calculate Pfold 

   Output
   1) Ps - Vector of Pfolds for each of the given starting positions
	"""
	
	def F_or_U( X ):
		if low_is_folded:
			if X[ foldDefinitionAxis ] < F_cut:
				return 'F'
			elif X[ foldDefinitionAxis ] > U_cut:
				return 'U'
		else:
			if X[ foldDefinitionAxis ] > F_cut:
				return 'F'
			elif X[ foldDefinitionAxis ] < U_cut:
				return 'U'

		return 'N'

	def either( X ):
		if F_or_U( X ) in [ 'F', 'U' ]:
			return True
		else:
			return False

	Pfolds = np.ones( len( x0 ) ) * -1
	for index, pos in enumerate( x0 ):
		numFolded = 0
		numTotal = 0
		print "Conformation %d" % index
		for i in range( N ):
			#print "Conf %d. Iteration: %5d / %d\r" % (index, i, N),
			OutPosS, success = Diffuse( pos, Vinit, dt = dt, T = T, gammas = gammas, noiseStdev = noiseStdev, noiseMean = noiseMean, num_iter=10000, until = either )
			if not success:
				print "Did not reach folded or unfolded in %d steps. If this happens a lot, then refine your parameters"
				continue
			else:
				#print F_or_U( OutPosS[-1] ), OutPosS[-1]
				numTotal += 1
				if F_or_U( OutPosS[-1] ) == 'F':
					numFolded += 1
		Pfolds[ index ] = float( numFolded ) / float( numTotal )

	return Pfolds

	
		








