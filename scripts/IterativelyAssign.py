#!/home/schwancr/epd-7.1-1-rh5-x86_64/bin/python -u
# This file is part of MSMBuilder.
#
# Copyright 2011 Stanford University
#
# MSMBuilder is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

import sys
import numpy
import os
import ArgLib

from msmbuilder import Project_CRS as Project
from msmbuilder import Trajectory
from msmbuilder import Serializer
from msmbuilder import Clustering
from random import randint
def run(Project, atomindices, Generators_Original,OutDir, rmsdCutoff,Assignments=None,RMSD=None,stride=1):
    # Check output isn't occupied
    AssFilename=OutDir+"/Assignments.Iterative.h5"
    AssRMSDFilename=OutDir+"/Assignments.Iterative.h5.RMSD"
    GensFilename=OutDir+"/Gens.Iterative.lh5"
    ArgLib.CheckPath(AssFilename)
    ArgLib.CheckPath(AssRMSDFilename)
    ArgLib.CheckPath("Gens.Iterative.lh5")  
    count = 0
    notDone = True    
    NumGen = 1000000
    GenIndList = []
    BadStateInd = None
    WhichTrajs=None
    WhichFrames=None
    Generators = Generators_Original.copy()
    if Assignments != None:
        SkipFirst = True
    else:
        SkipFirst = False
    while count <= 10000:
    # Do Assignments
        if not SkipFirst or count > 0:    
            if WhichFrames == None:
                totConfs = "all"
            else:
                totConfs = str( sum( [ len(thing) for thing in WhichFrames ] ) )
            print "-----------------------------------------------------------------"
            print "Iterative Assign Step %d:" % count, "Assigning data for %s conformations" % totConfs
            Assignments_Temp,RMSD_Temp,WhichTrajsWereAssigned=Project.AssignProject(Generators, AtomIndices=atomindices,WhichTrajs=WhichTrajs,WhichFrames=WhichFrames)

        if Assignments == None:
            Assignments = Assignments_Temp.copy()
            RMSD = RMSD_Temp.copy()
            del RMSD_Temp
            del Assignments_Temp
        elif BadStateInd == None:
            " Hi"
        else:
            UniqTrajs = numpy.unique( BadStateInd[:,0] ) # this returns the unique trajectory indices. 
            # NOTE: THIS IS ALSO SORTED. Since the badstateind is generated by arange, it is already sorted. So this is fine.
            UniqTrajs_Ind = numpy.arange( len( UniqTrajs ) )
            TrajConv = dict( zip( UniqTrajs, UniqTrajs_Ind ) )
            BadStateInd_Temp = BadStateInd.copy() # first copy the array, then translate the first column
            BadStateInd_Temp[:,0] = numpy.array([ TrajConv[ traj ] for traj in BadStateInd[:,0] ])
            print BadStateInd
            print BadStateInd_Temp
            assert Assignments[tuple(BadStateInd.T)].shape == Assignments_Temp[tuple(BadStateInd_Temp.T)].shape
            Assignments[tuple(BadStateInd.T)] = Assignments.max() + 1 + Assignments_Temp[tuple(BadStateInd_Temp.T)].copy()
            RMSD[tuple(BadStateInd.T)] = RMSD_Temp[tuple(BadStateInd_Temp.T)].copy()
            del RMSD_Temp
            del Assignments_Temp
        Serializer.SaveData( AssFilename + '.Step_%d' % count, Assignments )
        Serializer.SaveData( AssRMSDFilename + '.Step_%d' % count, RMSD )
    # Find conformations that don't really fit (i.e. RMSD >= cutoff)
        print "Step %d:" % count, "\tFinding bad states..."
        BadStateInd = numpy.array( numpy.where( RMSD >= rmsdCutoff ) ).T
        if not BadStateInd.any():
            notDone = False
            break

    # Cluster these bad states:
        if BadStateInd.shape[0] <= 50 * stride:
            if BadStateInd.shape[0] == 1:
                break
            BadStatesToCluster = Project.GetConformations( BadStateInd )
        else:
            BadStatesToCluster = Project.GetConformations( BadStateInd[::stride] )

        print "Re-clustering %d conformations out of %d total conformations" % ( BadStatesToCluster['XYZList'].shape[0], len( numpy.where( Assignments != -1 )[0] ) )
        XYZ = BadStatesToCluster["XYZList"]
        #BadStatesToCluster.SaveToLHDF("BadStates.lh5")
        print "Step %d:" % count, "\tClustering bad states..."
        KCentersInd=Clustering.KCenters.Cluster(XYZ,NumGen,RMSDCutoff=rmsdCutoff,Seed=randint(0,XYZ.shape[0]-1))
        GenInd=Clustering.HybridKMedoids.Cluster(XYZ,KCentersInd,LocalSearch=True)
        GenInd=KCentersInd
        GenIndList.append( GenInd )

    # Write over generators, I will load them all later...
        Generators['XYZList'] = XYZ[GenInd].copy()
        Generators_Original['XYZList'] = numpy.concatenate( (Generators_Original['XYZList'], Generators['XYZList'] ) )
        Generators_Original.SaveToLHDF( "%s.Step_%d" % ( GensFilename, count ) )
        if count > 0:
            os.remove( '%s.Step_%d' % ( AssFilename, count - 1 ) )
            os.remove( '%s.Step_%d' % ( AssRMSDFilename, count - 1 ) )
            os.remove( '%s.Step_%d' % ( GensFilename, count - 1 ) )
    # Prepare the indices to assign:
        tempArray = numpy.arange( Assignments.shape[0] )
        WhichTrajs = numpy.array( [ index for index in tempArray if index in BadStateInd[:,0] ] )
        WhichFrames = [ BadStateInd[:,1][ numpy.where( BadStateInd[:,0] == traj )] for traj in WhichTrajs ]

        count += 1
    Serializer.SaveData(AssFilename,Assignments)
    Serializer.SaveData(AssRMSDFilename,RMSD)
    # Need to save the new generators as well.
    Generators_Original.SaveToLHDF(GensFilename)
    print "Wrote: %s, %s"%(AssFilename,AssRMSDFilename)
    print "Saved %d Generators to Gens.Iterative.lh5" % Generators_Original['XYZList'].shape[0]
    return


if __name__ == "__main__":
    print """\nAssigns data to generators that was not originally used in the
clustering.\n
Output:
-- Assignments.h5: a matrix of assignments where each row is a vector
corresponding to a data trajectory. The values of this vector are the cluster
assignments.
-- Assignments.h5.RMSD: Gives the RMSD from the assigned frame to its Generator.
\n"""

    arglist=["projectfn", "generators", "atomindices","outdir","rmsdcutoff","assignments","assrmsd","stride"]
    options=ArgLib.parse(arglist)
    print sys.argv
    print options
    P1=Project.Project.LoadFromHDF(options.projectfn)
    AInd=numpy.loadtxt(options.atomindices, int)
    Generators=Trajectory.Trajectory.LoadTrajectoryFile(options.generators,Conf=P1.Conf)
    if options.assignments != "None":
        ass = Serializer.LoadData(options.assignments)
    else:
        ass = None
    if options.assrmsd != "None":
        assrmsd = Serializer.LoadData(options.assrmsd)
    else:
        assrmsd = None
    stride = int( options.stride )
    run(P1, AInd, Generators,options.outdir,float(options.rmsdcutoff),ass, assrmsd,stride)
