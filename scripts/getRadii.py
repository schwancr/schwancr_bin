#!/usr/bin/env python

# This script calculates native contacts between residues.

# The native contacts are input in a flat text file generated by the SMOG (UCSD) Go model website
# The format is: (First line is number of contacts)
# chainA atomA chainB atomB

# The script will calculate whether a given contact is satisfied below a certain cutoff at 
# every timestep in every trajectory in the input trajectory file.

# The output is a .npy file which is an N x M array where N = number of contacts, and M = # of snapshots

from optparse import OptionParser
parser = OptionParser()

parser.add_option('--nc','--native-contact-file',dest='nat_contactFN',help='Native contact file with a list of native contacts')
parser.add_option('--tr','--trajectory-dir',dest='trj_dir',help='Trajectory directory containing the trajectories in lh5 format. Default = ./Trajectories')
parser.add_option('-p','--project-info',dest='projFN',default='./ProjectInfo.h5',help='ProjectInfo.h5 from msmbuilder')
parser.add_option('-s','--states',dest='stateFN',help='State indices to get conformations from')
parser.add_option('-a','--assignments',dest='assFN',help='Assignments from msmbuilder')

(options,args) = parser.parse_args()

import re
import numpy as np
import sys
from msmbuilder import Trajectory
from msmbuilder import Project
import os
import multiprocessing as mp
from math import sqrt

def getConfs( state, Ass, Proj ):
   """ Get conformations (all of them) for a given state """
   ind = np.array(np.where( Ass == state ) ).T
   XYZList = []
   for x,y in ind:
      XYZList.append( Proj.ReadFrame(x,y) )

   traj = Proj.GetEmptyTrajectory()
   traj['XYZList'] = np.array( XYZList )
   
   return traj
  
def getContacts():
   global options

# First parse the contact file:
   contactFile = open(options.nat_contactFN,'r')
   lines = contactFile.readlines()
   contactList = []

   for line in lines[1:]:
      # Skip the first line of the file (it doesn't have contacts on it)
      contactList.append( ( int(line.split()[1]) , int(line.split()[3]) ) )
   
   contactFile.close()

   return contactList

def analyzeTrajectory(traj):
   global options
   global natContacts
# this function will analyze a trajectory for native contacts in the toTestLists


   outList = []
   for contact in natContacts:
      atomA = contact[0]
      atomB = contact[1]

      # Need to check the distance between these atoms in all frames:
      tempArray = []
          
      for frame in traj['XYZList']:
            
         coordA = frame[atomA-1]
         coordB = frame[atomB-1]
 
         diff = [ (thingA - thingB) for (thingA,thingB) in zip(coordA,coordB) ]          

         r2 = diff[0]*diff[0] + diff[1]*diff[1] + diff[2]*diff[2]
         tempArray.append( sqrt( r2 )  )

      outList.append(np.array(tempArray))
   

   arrayOut = np.array(outList).T  
   
   return arrayOut

def main():
   global options
   global natContacts
# Now generate a list of contacts to test. This will really be a list of lists, one for each pair
# And generate the cutoff dictionary that takes in a contact and then finds a cutoff
   natContacts = getContacts()
# Now I have read in all the data I need, I need to read in a trajectory and then analyze it.

   Proj = Project.Project.LoadFromHDF(options.projFN)
   Ass = Project.Serializer.LoadData(options.assFN)

   if options.stateFN[-4:] == '.npy':
      Ind = np.load(options.stateFN)
   else:
      try: Ind = np.loadtxt( options.stateFN , int)
      except: print "Cannot open file: %s" % options.stateFN; exit()
 
   if options.trj_dir:
      Proj['TrajFilePath'] = options.trj_dir

   outTot = np.array([])
   for state in Ind:
      print "Analyzing state %d" % state
      traj = getConfs( state, Ass, Proj )
      out = analyzeTrajectory( traj )
      np.save('./state%d.npy'%state,out )
      print "Wrote output to %s. Output had shape: " % ( './state%d.npy'%state ) + str( out.shape )
      outTot = np.concatenate( outTot, out )
   return 0

if __name__=='__main__':
   main()      
