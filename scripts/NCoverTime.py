#!/usr/bin/env python

# This script calculates native contacts between residues.

# The native contacts are input in a flat text file generated by the SMOG (UCSD) Go model website
# The format is: (First line is number of contacts)
# chainA atomA chainB atomB

# The script will calculate whether a given contact is satisfied below a certain cutoff at 
# every timestep in every trajectory in the input trajectory file.

# The output is a .npy file which is an N x M array where N = number of contacts, and M = # of snapshots

from optparse import OptionParser
parser = OptionParser()

parser.add_option('--nc','--native-contact-file',dest='nat_contactFN',help='Native contact file with a list of native contacts')
parser.add_option('--co','--cutoff-file',dest='cutoffFN',help='Cutoff file for a cutoff of each native contact that the user can define\n The default will be all contacts have a 6A cutoff.')
parser.add_option('--tr','--trajectories-directory',dest='trj_dir',default='./Trajectories',help='Trajectories directory containing hf5 formatted trajectories')
#parser.add_option('-n','--index-file',dest='ndx_file',help='Index file containing indices to test the native contacts at.\n'
	#							+'\tThere should be an even number of indices corresponding to a list\n'
	#							+'\tfor the first index and a list for the second.')
parser.add_option('-P','--procs',dest='procs',default=1,type=int, help='Number of procs to use in the calculation')
(options,args) = parser.parse_args()

import re
from numpy import *
import sys
from msmbuilder import Trajectory
import os
import multiprocessing as mp

def getContacts():
   global options

# First parse the contact file:
   contactFile = open(options.nat_contactFN,'r')
   lines = contactFile.readlines()
   contactList = []

   for line in lines[1:]:
      # Skip the first line of the file (it doesn't have contacts on it)
      contactList.append( ( int(line.split()[1]) , int(line.split()[3]) ) )
   
   contactFile.close()
   cutoffFile = open(options.cutoffFN,'r')
   cutoffDict = {}
   for line in cutoffFile.readlines():
      [atomA,atomB] = [ int(thing) for thing in line.split()[:2] ]
      cutoff = float( line.split()[2] )
      if (atomA,atomB) in cutoffDict or (atomB,atomA) in cutoffDict:
         print "(%d,%d) already in the cutoff dictionary! Using the oldest cutoff defined in cutoff file"
      else:
         cutoffDict[(atomA,atomB)] = cutoff*cutoff # Return the cutoff squared so I don't have to sqrt
   return contactList,cutoffDict

def analyzeTrajectory(trajFN):
   global options
   global natContacts
   global cutoff2Dict
# this function will analyze a trajectory for native contacts in the toTestLists

   print "Analyzing trajectory: %s ..." % trajFN

   traj = Trajectory.Trajectory.LoadFromLHDF(os.path.join(options.trj_dir,trajFN) )
   outList = []
   for contact in natContacts:
      atomA = contact[0]
      atomB = contact[1]

      # Need to check the distance between these atoms in all frames:
      tempArray = []
          
      for frame in traj['XYZList']:
            
         coordA = frame[atomA-1]
         coordB = frame[atomB-1]
 
         diff = [ (thingA - thingB) for (thingA,thingB) in zip(coordA,coordB) ]          

         r2 = diff[0]*diff[0] + diff[1]*diff[1] + diff[2]*diff[2]
         try: cutoff2 = cutoff2Dict[ (atomA,atomB) ]
         except: 
            try: cutoff2 = cutoff2Dict[ (atomB,atomA) ]
            except: 
               print "Cutoff not found for %d,%d, using default = 1.0" % (atomA,atomB)
               cutoff2 = 1
         tempArray.append( r2 <= cutoff2 )

      outList.append(array(tempArray))
   

   arrayOut = array(outList).T  
   save(trajFN[:-4],arrayOut )

   print "Wrote output to %s. Output had shape: " % (trajFN[:-4]+'.npy') + str( arrayOut.shape )
   
   return 0

def main():
   global options
   global natContacts
   global cutoff2Dict
# Now generate a list of contacts to test. This will really be a list of lists, one for each pair
# And generate the cutoff dictionary that takes in a contact and then finds a cutoff
   natContacts, cutoff2Dict = getContacts()
# Now I have read in all the data I need, I need to read in a trajectory and then analyze it.
   output = []
   trajList = [ thing for thing in os.listdir(options.trj_dir) if 'lh5' in thing ]

   pool = mp.Pool(options.procs)
   result = pool.map_async(analyzeTrajectory,trajList)
   result.wait()

   sol = array(result.get())
   if sum(sol) != 0:
      print "Error in processing some traj's!!!"   
   return 0

if __name__=='__main__':
   main()      
